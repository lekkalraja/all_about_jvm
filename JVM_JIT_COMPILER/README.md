# JVM JIT (Just In Time) Compiler (Running on JAVA-11)

The Java compiler (javac) will compile your *.java class into a *.class file. 
    ```
        > javac Main.java  >> Main.class
    ```
This *.class is your bytecode.

The Generated bytecode (*.class files) can be packaged into a JAR file or a WAR file. 
When we are running our app using the java command, the JVM will run our bytecode

    ```
        > java Main
    ```
Due to this, the interpreter at runtime (JVM) can achieve one of its benefits, WORA (Write Once, Run Anywhere with consistent Results).

# JIT COMPILER
   - There are some scenarios, where we can get best performance only when we compilled our code(or some part of code) into executable code (i.e. The operating system understandable code). For this, Java HostSpot VM has a feature called **JIT (Just In Time)** Compiller.

   * JVM will monitor which block of code running most often, if so then decide the code execution would be speeded up if that block of code compiled to native machine code (executable code) and it will do with the help of JIT Compiller.*

   > NOTE: The process of compiling the bytecode to native machine code will run in a separate thread

   * While the compilation is taking place, the JVM will continue to use the interpreted version but once that compilation is complete and the native machine code version is available, then the JVM will seamlessly switch to use the JIT-compiled version instead of the bytecode. This process is called on-stack replacement (OSR) *


# JDK has 2 different compilers. 
    1. javac  : Responsible for compiling Java code for bytecode

    2. Just In Time (JIT) (part of the JVM) : 
        * It is Composed of 2 'sub-compilers'*
            - C1 (Client Compiler, available both in 32 bit and 64 bit JVM)
            - C2 (Server Compiler, available only in 64 bit JVM)

            * The C1 will take the bytecode and optimize the code by profiling (basically enriching the Java code metadata according to the number of executions) in 3 layers and when realizing that this is a very used code based on the information contained in profiling, C2 will compile this code for Native code and then place it in **~~CodeCache~~** *

# DEMO
 In our Workspace we have two files : Main.java and PrimeNumbers.java

 ```
    To Compile code :> javac Main.java PrimeNumbers.java
    To Run/Execute  :> java Main 40
 ```

 ## To check and analyze the JIT Compilation logs
   - -XX:+PrintCompilation

   ```
    :> java -XX:+PrintCompilation Main 40

    timestamp compilation_id attributes tiered_level method_name size deopt
    123    1       3       java.lang.Object::<init> (1 bytes)
    123    2       3       java.lang.StringLatin1::hashCode (42 bytes)
    123    4       3       java.lang.String::hashCode (49 bytes)
    124    3       3       java.lang.String::isLatin1 (19 bytes)
    124    5       3       java.lang.String::coder (15 bytes)
    125    6       3       java.lang.Math::floorMod (10 bytes)
    125    7       3       java.util.ImmutableCollections$SetN::probe (56 bytes)
    127    8       3       java.lang.Math::floorDiv (22 bytes)
    128   10       3       java.lang.StringLatin1::equals (36 bytes)
    128    9       3       java.lang.String::equals (65 bytes)
    129   12       3       java.util.Collections::emptySet (4 bytes)
    129   11       1       java.util.Collections$EmptySet::hashCode (2 bytes)
    130   14       3       java.lang.module.ModuleDescriptor$Exports::hashCode (38 bytes)
    130   15       3       java.util.AbstractCollection::<init> (5 bytes)
    130   17       3       java.util.Objects::requireNonNull (14 bytes)
    131   16       3       java.util.ImmutableCollections$AbstractImmutableSet::<init> (5 bytes)
    131   19       1       java.lang.Object::<init> (1 bytes)
    131    1       3       java.lang.Object::<init> (1 bytes)   made not entrant
    132   18       3       java.util.Set::of (66 bytes)
    132   13       4       java.lang.StringLatin1::hashCode (42 bytes)
    133   20       1       java.lang.module.ModuleDescriptor::name (5 bytes)
    134   21       1       java.lang.module.ModuleReference::descriptor (5 bytes)
    137   22       3       java.util.concurrent.ConcurrentHashMap::tabAt (22 bytes)
    139    2       3       java.lang.StringLatin1::hashCode (42 bytes)   made not entrant
    140   23       3       jdk.internal.misc.Unsafe::getObjectAcquire (7 bytes)
    144   24       3       java.lang.String::charAt (25 bytes)
    146   25       3       java.lang.StringLatin1::charAt (28 bytes)
    150   26       3       java.util.ImmutableCollections$SetN$SetNIterator::hasNext (13 bytes)
    150   27       3       java.util.ImmutableCollections$SetN$SetNIterator::nextIndex (56 bytes)
    150   28       3       java.util.ImmutableCollections$SetN$SetNIterator::next (47 bytes)
    152   29       1       java.util.KeyValueHolder::getKey (5 bytes)
    152   30       1       java.util.KeyValueHolder::getValue (5 bytes)
    152   31       3       java.util.ImmutableCollections$MapN::probe (60 bytes)
    153   32       3       java.util.Objects::equals (23 bytes)
    153   33       3       java.util.KeyValueHolder::<init> (21 bytes)
    154   34       3       jdk.internal.module.ModuleReferenceImpl::hashCode (56 bytes)
    157   38   !   3       java.util.concurrent.ConcurrentHashMap::putVal (432 bytes)
    157   40     n 0       jdk.internal.misc.Unsafe::compareAndSetLong (native)
    158   43     n 0       jdk.internal.misc.Unsafe::compareAndSetObject (native) **   
    161   39       3       java.util.concurrent.ConcurrentHashMap::addCount (289 bytes)
    163   37       3       java.util.concurrent.ConcurrentHashMap::spread (10 bytes)
    163   41       3       java.util.concurrent.ConcurrentHashMap$Node::<init> (20 bytes)
    164   42       3       java.util.concurrent.ConcurrentHashMap::putIfAbsent (8 bytes)
    164   44       3       java.util.concurrent.ConcurrentHashMap::casTabAt (21 bytes)
    164   35       3       java.util.HashMap::hash (20 bytes)
    164   36       1       java.lang.module.ResolvedModule::reference (5 bytes)
    165   45       1       java.util.ImmutableCollections$SetN::size (5 bytes)
    165   46     n 0       java.lang.System::arraycopy (native)   (static)
    166   49       3       java.util.HashMap::getNode (148 bytes)
    167   51       3       java.util.HashMap::putVal (300 bytes)
    169   50       3       java.util.HashMap::put (13 bytes)
    169   52       3       java.util.HashMap$Node::<init> (26 bytes)
    169   53       3       java.util.HashMap::newNode (13 bytes)
    170   54       3       java.util.HashMap::afterNodeInsertion (1 bytes)
    170   47       3       java.util.HashMap::get (23 bytes)
    170   59     n 0       java.lang.Object::hashCode (native)
    170   55       1       java.lang.module.ModuleDescriptor$Exports::source (5 bytes)
    170   56       1       java.util.Collections$EmptySet::isEmpty (2 bytes)
    170   48       3       java.lang.module.ResolvedModule::name (11 bytes)
    171   58       3       java.util.ImmutableCollections$Set12$1::hasNext (13 bytes)
    171   60       3       java.util.HashSet::add (20 bytes)
    172   57       1       java.lang.module.ModuleDescriptor::isAutomatic (5 bytes)
    172   62       1       java.lang.module.ResolvedModule::configuration (5 bytes)
    173   61       3       java.util.ImmutableCollections$Set12::size (13 bytes)
    173   63       3       java.lang.Math::min (11 bytes)
    174   64       3       java.util.Map::entry (10 bytes)
    176   65       3       java.util.ImmutableCollections$Set12$1::next (92 bytes)
    176   66       1       java.lang.module.ModuleDescriptor::isOpen (5 bytes)
    176   67       4       java.lang.String::hashCode (49 bytes)
    177   69       3       java.util.ImmutableCollections$MapN::get (35 bytes)
    178   73       3       java.util.HashMap::resize (356 bytes)
    179   76     n 0       java.lang.Module::addExportsToAllUnnamed0 (native)   (static)
    180   74       1       java.util.HashMap::afterNodeInsertion (1 bytes)
    180   54       3       java.util.HashMap::afterNodeInsertion (1 bytes)   made not entrant
    180   70       3       jdk.internal.module.ModuleBootstrap$2::hasNext (30 bytes)
    181   71       3       jdk.internal.module.ModuleBootstrap$2::next (52 bytes)
    181   75       3       java.util.HashMap::putIfAbsent (13 bytes)
    182   72       1       java.lang.Module::getDescriptor (5 bytes)
    184    4       3       java.lang.String::hashCode (49 bytes)   made not entrant
    184   68       4       java.util.ImmutableCollections$SetN$SetNIterator::hasNext (13 bytes)
    185   67       4       java.lang.String::hashCode (49 bytes)   made not entrant
    186   26       3       java.util.ImmutableCollections$SetN$SetNIterator::hasNext (13 bytes)   made not entrant
    186   77       3       java.lang.String::hashCode (49 bytes)
    187   78       3       java.lang.String::length (11 bytes)
    192   79       3       java.lang.StringLatin1::indexOf (61 bytes)
    193   80       3       java.lang.StringLatin1::canEncode (13 bytes)
    208   81       3       sun.nio.fs.UnixPath::checkNotNul (16 bytes)
    211   82       3       java.lang.AbstractStringBuilder::ensureCapacityInternal (39 bytes)
    212   83       1       java.lang.Integer::intValue (5 bytes)
    212   84       1       java.lang.Boolean::booleanValue (5 bytes)
    212   85       3       PrimeNumbers::isPrime (35 bytes)
   ```

   - ** timestamp ** (milliseconds) he time after the JIT compilation has finished (relative to 0, which is when the JVM started).
   - ** compilation_id **  is an internal task identifier.sometimes number out of sync due to multiple compilation threads running 
   out of order (faster or slower)
   - ** attributes ** a string that indicate the state of the code that is being compiled.
        -  % - The compilation is OSR (on-stack replacement).
        -  s - The method is synchronized.
        -  ! - The method has an exception handler.
        -  b - Compilation occurred in blocking mode
        -  n - Compilation occurred for a wrapper to a native method.

    - **tiered_level** tiered compilation can be disabled with the option ** -XX:-TieredCompilation**, as a result the field tiered_level will be blank. Otherwise, it will be a number indicating which tier has completed compilation. This number can go from 0 to 4.
    At tier 0, the code was not compiled, the code was just interpreted.
    At tiers 1, 2, 3 the code was compiled by C1 with different amounts of extra profiling. The most optimized of them are tier 1 since it has no profiling overhead.
    At tier 4 the code is compiled by C2. It means that now the code was compiled at the highest possible level of compilation and was added in the code cache.

    - ** deopt** In some cases there is a message at the end of the compilation line that will indicate that some sort of deoptimization (deopt) has occurred, and they can be “made not entrant” or “made zombie”.

    - Deoptimization can happen in two cases : 
        - when code is ** made not entrant** : 
            1. when we are using polymorphism and interfaces
            2. During the tiered compilation (from 1 to 4)
        - when code is ** made zombie**
            - That compiled code is kept in a fixed-size code cache. When zombie methods are identified, this code can be removed  from the code cache, making room for other code to be compiled and added there

# Knowing more about compilation

    ```
        > java -XX:+UnlockDiagnosticVMOptions -XX:+LogCompilation Main 40
        - Above command will create a file <PWD>/hotspot_pid<number>.log
        - can change the location of the file, using the flag -XX:LogFile=<PATH>
    ``` 

    # For Better Understanding of the generated JIT Log file
    -  open-source project called JITWatch, maintained by AdoptOpenJDK
    -  To generate the hotspot.log file used by JITWatch, we need one more flag, and it is “-XX:+TraceClassLoading”
    ```
        > git clone https://github.com/AdoptOpenJDK/jitwatch.git
        > cd jitwatch && mvn clean compile exec:java
    ```

# Code cache
    Code cache is a special area of memory, that will be the quickest way for accessible and execution.
    
    # When we have a code compiled to tier 4, eventually this code will be added at Code Cache. The problem here is Code Cache is a limited size, so, in case of large number of methods compiled to tier 4, eventually some code will be remove from the Code Cache to make space for the next code, In other words, in large applications with a lot of methods (code blocks) that could be compiled to level four over time, some methods might be moved into the Code Cache, then moved out, then moved back again, and so on.

    - JVM will log a warning message in the console of our application when code cache is full.
        ```
            VM warning: CodeCache is full. The compiler has been disabled.
            
            Note: This warning won’t stop our application!
        ```
    - To See the Information about Code Cache
        ```
            > java -XX:+PrintCodeCache Main 100

            CodeHeap 'non-profiled nmethods': size=120032Kb used=21Kb max_used=21Kb free=120010Kb
                bounds [0x00007fd44387b000, 0x00007fd443aeb000, 0x00007fd44adb3000]
            CodeHeap 'profiled nmethods': size=120032Kb used=123Kb max_used=123Kb free=119908Kb
                bounds [0x00007fd43c343000, 0x00007fd43c5b3000, 0x00007fd44387b000]
            CodeHeap 'non-nmethods': size=5696Kb used=985Kb max_used=995Kb free=4710Kb
                bounds [0x00007fd43bdb3000, 0x00007fd43c023000, 0x00007fd43c343000]
                total_blobs=391 nmethods=93 adapters=158
                compilation: enabled
                              stopped_count=0, restarted_count=0
                full_count=0
        ```
    ### Note: For Java 8 or above the max size will be 240 megabytes, 
    if you disable tiered compilation with the option -XX:-TieredCompilation, then the default size is 48 megabytes.

    ## To change the size's of Code Cache
        1. -XX:InitialCodeCacheSize : size of the Code Cache when the application starts. By default, this value is really low, around 160 kilobytes.
        2. -XX:ReservedCodeCacheSize : maximum size of the Code Cache.
        3. -XX:CodeCacheExpansionSize : This flag is responsible for dictating how quickly the code cache should grow. It means how much extra space should be added each time the code cache grows.

        We can use bytes, kilobytes, megabytes, or gigabytes.

        ```
            > java -XX:initialCodeCacheSize=40k -XX:ReservedCodeCacheSize=1g -XXCodeCacheExpansionSize=3m Main
        ```
    
    # We can watch cache-code metrics visually using JConsole of jdk


# Tune Applicaiton
    1. The maximum total process size (that includes the heap, permgen, and the native code and native memory the JVM uses) for the 32-bit JVM is 4G, and for the 64-bit JVM depends on the OS that this JVM is running. So, if you have an application that needs less than 3G of heap memory to run, the 32-bit will be faster, and the reason is that each pointer to an object in memory is smaller, so handling these pointers will be quicker.

    2. We have two different types of applications, the ephemeral applications (also called Client applications) and the webserver applications (also called Server applications). Basically the difference is regarding the lifetime of the application. The client applications have a short lifetime and the server applications have a long lifetime.

    3. For ephemeral applications, start-up time is really important because these applications won’t run very long, so the JIT compiler won’t have time to make the tiered compilation be worth it (because probably no method will run many times to be eligible to tier 4). That’s why in the 32-bit JVM we only have a client compiler (C1).

    4. For web server applications, the JIT compilation is more important than the start-up time, because the JIT compiler will have time to profile the bytecode, put it into the tier 4 and then add this code to a Code Cache.

    ## There are 3 flags to specify which compiller should use at runtime
        - ** -client ** : JIT Compiler should only use the 32-bit client compiler.
        - ** -server ** : JIT Compiler should only use the 64-bit server compiler.
        - ** -d64 ** : JIT Compiler should use the 64-bit server compiler.

    ## We can turn of the Tiered Compillation as well we can specify the level of the tiered compilation the JIT Compiler should stop
        - -XX:-TieredCompilation
        - -XX:TieredStopAtLevel=<LEVEL>
    
    # To check how many threads are available for the compiling process.

        ```
            > java -XX:-PrintFlagsFinal && then check for CICompilerCount
            -      intx CICompilerCount                          = 3                                         {product} {ergonomic}

            > jinfo -flag CICompilerCount <JAVA_PROCESS_ID>
        ```
        - We can play with the count of threads while running the application (min should be 2)
        ```
            > java -XX:CICompilerCount=6 -XX:+PrintCompilation Main
        ```
    # To  check what is the threshold for native compilation, i.e. how many times a method should run to be compiled into native code (tier 4).

    ```
        > java -XX:+PrintFlagsFinal && and then check for CompileThreshold
        -      intx CompileThreshold                         = 10000                                  {pd product} {default}
        > > jinfo -flag CompileThreshold <JAVA_PROCESS_ID>
    ```

    - We can play with the count of CompileThreshold while running the application
        ```
            > java -XX:CompileThreshold=6 -XX:+PrintCompilation Main
        ```
===================================================================================================================================